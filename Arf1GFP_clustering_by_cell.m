

close all; clear variables; clc

%% Setting and creating directories

currdir = pwd;
addpath(pwd);
filedir = uigetdir();
cd(filedir);
filedir_file = dir('*.oib');

% contains information on the cell borders
borders = [filedir, '/borders/'];
cd(borders)

% binary_tifs folder contains the binary image files of the objects
files_tifs = [filedir, '/binary_tifs'];
cd(files_tifs)
object_files = dir('*.tif');

% creating main result directory
if exist([filedir, '/analysis'],'dir') == 0
    mkdir(filedir,'/analysis');
end
analysis_folder = [filedir, '/analysis'];

%% counter for objects analysed
no_analysed_images = 0;
no_analysed_cells = 0;

%% Obtain border imformation from 'handCorrection.tif' file generated by TissueAnalyzer

for kk = 1:numel(object_files)
    cd(borders)
    bd_dir = [borders, '/', num2str(kk)];
    cd(bd_dir)
    I=imread('handCorrection.tif');
    I=imbinarize(rgb2gray(I),0);
    I(:,1) = 0;
    I(:,end) = 0;
    I(1,:) = 0;
    I(end,:) = 0;
    [im_x, im_y] = size(I);
    [B,L,N,A] = bwboundaries(I,'holes');
    im_cell_data = regionprops(L, 'Centroid');

    % keep track of each image analysed
    no_analysed_images = no_analysed_images + 1
    
    % create results directory for each image
    
     if exist ([filedir, ['/analysis/', num2str(kk), '/centroids'], 'dir']) == 0
        mkdir (filedir, ['/analysis/', num2str(kk), '/centroids']);
    end
    centroid_overlay = [filedir, ['/analysis/', num2str(kk), '/centroids']];
    
    if exist ([filedir, ['/analysis/', num2str(kk), '/edge_lengths'], 'dir']) == 0
        mkdir (filedir, ['/analysis/', num2str(kk), '/edge_lengths']);
    end
    results_sheets = [filedir, ['/analysis/', num2str(kk), '/edge_lengths']];
    
    if exist ([filedir, ['/analysis/', num2str(kk), '/norm_edge_lengths'], 'dir']) == 0
        mkdir (filedir, ['/analysis/', num2str(kk), '/norm_edge_lengths']);
    end
    results_sheets_norm = [filedir, ['/analysis/', num2str(kk), '/norm_edge_lengths']];
    
    results_by_image = [filedir, '/analysis/', num2str(kk)];

    % determine centroid position for each cell in the image
    for ii=1:length(im_cell_data)
        x_centroid_cell(ii) = im_cell_data(ii).Centroid(1);
        y_centroid_cell(ii) = im_cell_data(ii).Centroid(2);
    end

    % excluding first element which is the parent object, use 3 for double
    % stripes
    x_centroid_cell = x_centroid_cell(2:length(im_cell_data));
    y_centroid_cell = y_centroid_cell(2:length(im_cell_data));

    x_centroid_cell = x_centroid_cell(:);
    y_centroid_cell = y_centroid_cell(:);

    Image1= figure; 
    imshow(I); hold on;
    % Loop through object boundaries  
    % showing the cells identified with complete borders
    for k = 1:N
        % Boundary k is the parent of a hole if the k-th column
        % of the adjacency matrix A contains a non-zero element
        if (nnz(A(:,k)) > 0)
            boundary = B{k};
            plot(boundary(:,2),...
                boundary(:,1),'w','LineWidth',1);
            % Loop through the children of boundary k
            for l = find(A(:,k))'
                boundary = B{l};
                plot(boundary(:,2),...
                    boundary(:,1),'g','LineWidth',2);
            end
        end
    end; hold on; plot(x_centroid_cell, y_centroid_cell, 'r*')

    cd(analysis_folder)
    Output_Graph = [num2str(kk),'_borders'];
    hold off
      print(Image1, '-dtiff', '-r300', Output_Graph);

    % removes first cell which is the 'whole' image
    B_fixed = B;
    B_fixed(1) = []; % Note: boundary coordinates are organised in (y, x) format

    edge_lengths = zeros(length(B_fixed), 1);
    
    for ww = 2:length(B_fixed)
        close all
        I_mask = imdilate(poly2mask(B_fixed{ww}(:,2),B_fixed{ww}(:,1),im_x,im_y), strel('diamond', 1));
        stat_mask = regionprops(I_mask, 'Area', 'Orientation');
        cd(files_tifs)
             Q = [num2str(kk),'.tif'];
            I_object = imread(Q); 
            I_object = logical(I_object);

            ROI = I_object;
            ROI(I_mask== 0) = 0;
            ROI2 = logical(ROI); %

            % keep track of cells analysed
            no_analysed_cells = no_analysed_cells + 1
            
            im_object_data = regionprops (ROI2, 'Centroid');
            for jj=1:numel(im_object_data)
                x_centroid_object(jj) = im_object_data(jj).Centroid(1);
                y_centroid_object(jj) = im_object_data(jj).Centroid(2);   
            end

            if isempty(im_object_data)
               continue
                % move to next loop iteration
            end
            
            x_centroid_object = x_centroid_object(:);
            y_centroid_object = y_centroid_object(:);

            x_centroid = x_centroid_object(1:jj);
            y_centroid = y_centroid_object(1:jj);
                
            if length(im_object_data) < 4
               continue
                % move to next loop iteration if line intersects with
                % more than 2 borders
            end
                       
            DT = delaunayTriangulation(x_centroid, y_centroid);

            % image2 saves centroid positions, with csv file
			image2 = figure; set(gcf,'Visible', 'off');
			plot(x_centroid, y_centroid, 'b*');
			ax = gca;
			ax.YDir = 'reverse'
		    
			%image3 shows centroid positions overlaid on binary image
			image3 = figure; set(gcf,'Visible', 'off');
			imshow(ROI2)
			hold on
			plot(x_centroid, y_centroid, 'b*')
			ax = gca
			ax.YDir = 'reverse'
		    
			%image4 triplot of DT analysis using centroid positions
			image4 =figure; set(gcf,'Visible', 'off');
			triplot(DT)
			hold on
			plot(x_centroid, y_centroid, 'r*')
			ax = gca
			ax.YDir = 'reverse'

			image5 = figure; set(gcf,'Visible', 'on');
			triplot(DT)
			hold on 
			ax = gca
			ax.YDir = 'reverse'
			edges = DT.edges;
			edgeLens = zeros(size(edges,1),1);
			for i = 1:size(edges,1)
			    thisEdgePts = DT.Points(edges(i,:),:);
			    edgeCpt = mean(thisEdgePts,1);
			    edgeLen = sqrt(sum(diff(thisEdgePts,[],1).^2));
			    edgeLens(i) = edgeLen;
			    text(edgeCpt(1),edgeCpt(2),sprintf('%0.1f',edgeLen),'HorizontalAlignment','center')
			end
			hold off
            
            
            cd(centroid_overlay)
			Output_Graph = [num2str(ww),'_centroids_overlay.tif'];
			hold off
			print(image3, '-dtiff', '-r300', Output_Graph)
            
			cd(results_by_image)
			Output_Graph = [num2str(ww),'_DT_edgeLens.tif'];
			hold off
			print(image5, '-dtiff', '-r300', Output_Graph)
            
            cd(results_sheets)
            edgeLens = nonzeros(edgeLens);
            if ~isempty(edgeLens)
                csvwrite(['Image' num2str(kk), '_cell' num2str(ww), '_edge_lengths.csv'], edgeLens(:))
            else
                % do nothing
            end
            
            norm_edge_len = edgeLens/max(edgeLens);
            
            cd(results_sheets_norm)
            stat_mask.Area = nonzeros(norm_edge_len);
            if ~isempty(norm_edge_len)
                csvwrite(['Image' num2str(kk), '_cell' num2str(ww), '_norm_len.csv'], norm_edge_len(:))
            else
                % do nothing
            end
            
            cd(results_sheets)
            stat_mask.Area = nonzeros(stat_mask.Area);
            if ~isempty(stat_mask.Area)
                csvwrite(['Image' num2str(kk), '_cell' num2str(ww), '_cell_area.csv'], stat_mask.Area(:))
            else
                % do nothing
            end
         
    end

end

close all; clear variables; clc

